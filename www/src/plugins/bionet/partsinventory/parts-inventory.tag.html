<parts-inventory>
  <content-container style="padding-top:100px;">
    <section-container>
      <form onsubmit={self.submitForm}>
        <search-input label="search inventory" name="searchbio" action={searchclick}/>
        <input type="submit" style="display:none" />
      </div>
      <div id="part-inventory-content" class="{theme.style.color.background} {theme.style.color.text}">
        <inventory-treeview nodes={self.nodes} />
      </div>
    </section-container>
  </content-container>
  <script>
    const tag = this
 
    self.nodes = [];

    self.submitForm = function() {

      riot.route('/inventory?q='+encodeURIComponent(self.searchbio.value))
    }


    this.on('mount', function() {
      if(!this.opts.q) return;
      var q = decodeURIComponent(this.opts.q);
      self.searchbio.value = q;

      this.update();

      q = new RegExp(q.replace(/\s+/, '.*'), 'i');


      function itemFromNode(node) {

      }

      // TODO remove settimeout
      setTimeout(function() {

        app.remote.inventoryTree(function(err, children) {
          if(err) return console.error(err);

          // TODO rewrite this matching algorithm 
          //      so we can do single-pass matching
          //      so we can use a stream
   
          var matches = [];
          self.nodes = [];

          var i, cur, indent, a;
          for(i=0; i < children.length; i++) {
            cur = children[i].path;
            if(cur.match(q)) matches.push(cur);
          }

          var j, m, add, perfect;
          for(i=0; i < children.length; i++) {
            cur = children[i].path; 
            a = cur.split('.');
            indent = a.length - 1;
            add = false
            perfect = false
            for(j=0; j < matches.length; j++) {
              m = matches[j];
              if(m.indexOf(cur) === 0) {
                add = true;
                if(m.length === cur.length) perfect = true;
                break;
              }
            }
            if(add) {
              self.nodes.push({
                indent: indent,
                primary_text: a[a.length-1],
                id: children[i].key,
                highlight: perfect
              });
            }
          }          

          tag.update();

        });
      }, 500);
    })


  </script>
</parts-inventory>

<inventory-treeview>

  <list-container>
    <ul style="margin:0 0 0 1em;position:relative">
      <li style="padding:0 1.5em;">
        <list-item each={node in nodes} item={node} />
      </li>
    </ul>
  </list-container>

  <script>
    /*
    <list-header primary-header={primaryHeader} secondary-header={secondaryHeader}/>
    */
    const tag = this;


    this.on('mount', function() {

    });

    this.on('updated', function() {
      
    });

/*
    self.primaryHeader = 'Lab inventory'
    const tag = this
    self.subitems = []

    app.observe('inventory', function(list) {
      self.secondaryHeader = ''
      self.searchresult = list

      var item = list
      var subitems = []
      for (var key in item) {
        if (item.hasOwnProperty(key)) {
          var ditem = {
            primary_text: key,
            subitem: item[key]
          }
          subitems.push(ditem)
        }
      }
      self.subitems = subitems
      console.log('inventory-treeview :',JSON.stringify(subitems))
      tag.update()
    })

*/
  </script>

</inventory-treeview>
